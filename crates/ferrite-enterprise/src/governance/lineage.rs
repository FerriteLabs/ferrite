//! Data Lineage Tracking
//!
//! Track data provenance, transformations, and dependencies across the system.

use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet, VecDeque};

/// Unique identifier for lineage nodes
pub type NodeId = String;

/// Lineage event types
#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum LineageEvent {
    /// Data creation
    Create {
        key: String,
        source: DataSource,
        timestamp: u64,
        metadata: HashMap<String, String>,
    },
    /// Data transformation
    Transform {
        input_keys: Vec<String>,
        output_key: String,
        operation: TransformOperation,
        timestamp: u64,
    },
    /// Data derivation (copying/cloning)
    Derive {
        source_key: String,
        derived_key: String,
        timestamp: u64,
    },
    /// Data merge
    Merge {
        source_keys: Vec<String>,
        target_key: String,
        timestamp: u64,
    },
    /// Data deletion
    Delete { key: String, timestamp: u64 },
    /// Data export
    Export {
        key: String,
        destination: String,
        timestamp: u64,
    },
    /// Data import
    Import {
        key: String,
        source: String,
        timestamp: u64,
    },
}

/// Data source types
#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum DataSource {
    /// User input via API
    Api {
        user_id: Option<String>,
        client_ip: Option<String>,
    },
    /// Imported from file
    File { path: String },
    /// Imported from external system
    External { system: String, identifier: String },
    /// Generated by computation
    Computed { operation: String },
    /// Replicated from another node
    Replicated { source_node: String },
    /// Unknown origin
    Unknown,
}

/// Transform operation types
#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum TransformOperation {
    /// Aggregation (SUM, COUNT, AVG, etc.)
    Aggregate { function: String },
    /// Filter operation
    Filter { predicate: String },
    /// Map/Transform values
    Map { transformation: String },
    /// Join operation
    Join { join_type: String },
    /// Custom WASM function
    Wasm { function_name: String },
    /// Query result
    Query { query: String },
    /// Trigger execution
    Trigger { trigger_name: String },
    /// Unknown transformation
    Unknown,
}

/// Node in the lineage graph
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct LineageNode {
    /// Node ID
    pub id: NodeId,
    /// Key this node represents
    pub key: String,
    /// Node type
    pub node_type: LineageNodeType,
    /// Creation timestamp
    pub created_at: u64,
    /// Last modified timestamp
    pub modified_at: u64,
    /// Data source
    pub source: Option<DataSource>,
    /// Node metadata
    pub metadata: HashMap<String, String>,
}

/// Lineage node types
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub enum LineageNodeType {
    /// Raw data
    Raw,
    /// Derived/transformed data
    Derived,
    /// Aggregated data
    Aggregated,
    /// External data
    External,
    /// Deleted (tombstone)
    Deleted,
}

/// Edge in the lineage graph
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct LineageEdge {
    /// Source node ID
    pub source: NodeId,
    /// Target node ID
    pub target: NodeId,
    /// Edge type
    pub edge_type: LineageEdgeType,
    /// Timestamp of the relationship
    pub timestamp: u64,
    /// Operation that created this edge
    pub operation: Option<String>,
}

/// Lineage edge types
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub enum LineageEdgeType {
    /// Direct derivation
    DerivedFrom,
    /// Transformation input
    TransformInput,
    /// Aggregation source
    AggregatedFrom,
    /// Copy/clone
    CopiedFrom,
    /// Merge source
    MergedFrom,
    /// Dependency
    DependsOn,
}

/// Complete lineage information for a key
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct DataLineage {
    /// The key this lineage is for
    pub key: String,
    /// Root node
    pub node: Option<LineageNode>,
    /// Upstream nodes (data this depends on)
    pub upstream: Vec<LineageNode>,
    /// Downstream nodes (data that depends on this)
    pub downstream: Vec<LineageNode>,
    /// All edges in this lineage
    pub edges: Vec<LineageEdge>,
    /// Lineage depth (max hops to root)
    pub depth: usize,
}

/// Lineage graph for tracking data provenance
pub struct LineageGraph {
    /// Nodes indexed by ID
    nodes: HashMap<NodeId, LineageNode>,
    /// Key to node ID mapping
    key_to_node: HashMap<String, NodeId>,
    /// Outgoing edges from each node
    outgoing_edges: HashMap<NodeId, Vec<LineageEdge>>,
    /// Incoming edges to each node
    incoming_edges: HashMap<NodeId, Vec<LineageEdge>>,
    /// Event history
    events: VecDeque<LineageEvent>,
    /// Max events to retain
    max_events: usize,
    /// Next node ID
    next_id: u64,
}

impl LineageGraph {
    /// Create a new lineage graph
    pub fn new() -> Self {
        Self {
            nodes: HashMap::new(),
            key_to_node: HashMap::new(),
            outgoing_edges: HashMap::new(),
            incoming_edges: HashMap::new(),
            events: VecDeque::new(),
            max_events: 10000,
            next_id: 1,
        }
    }

    /// Create with custom max events
    pub fn with_max_events(max_events: usize) -> Self {
        Self {
            max_events,
            ..Self::new()
        }
    }

    /// Add a lineage event
    pub fn add_event(&mut self, event: LineageEvent) {
        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap_or_default()
            .as_secs();

        match &event {
            LineageEvent::Create {
                key,
                source,
                metadata,
                ..
            } => {
                self.create_node(key, source.clone(), metadata.clone(), now);
            }
            LineageEvent::Transform {
                input_keys,
                output_key,
                operation,
                ..
            } => {
                self.add_transform(input_keys, output_key, operation.clone(), now);
            }
            LineageEvent::Derive {
                source_key,
                derived_key,
                ..
            } => {
                self.add_derivation(source_key, derived_key, now);
            }
            LineageEvent::Merge {
                source_keys,
                target_key,
                ..
            } => {
                self.add_merge(source_keys, target_key, now);
            }
            LineageEvent::Delete { key, .. } => {
                self.mark_deleted(key, now);
            }
            LineageEvent::Export { .. } | LineageEvent::Import { .. } => {
                // Track but don't modify graph structure
            }
        }

        // Store event
        self.events.push_back(event);
        while self.events.len() > self.max_events {
            self.events.pop_front();
        }
    }

    fn create_node(
        &mut self,
        key: &str,
        source: DataSource,
        metadata: HashMap<String, String>,
        timestamp: u64,
    ) -> NodeId {
        let node_id = format!("node_{}", self.next_id);
        self.next_id += 1;

        let node = LineageNode {
            id: node_id.clone(),
            key: key.to_string(),
            node_type: LineageNodeType::Raw,
            created_at: timestamp,
            modified_at: timestamp,
            source: Some(source),
            metadata,
        };

        self.nodes.insert(node_id.clone(), node);
        self.key_to_node.insert(key.to_string(), node_id.clone());
        self.outgoing_edges.insert(node_id.clone(), Vec::new());
        self.incoming_edges.insert(node_id.clone(), Vec::new());

        node_id
    }

    fn add_transform(
        &mut self,
        input_keys: &[String],
        output_key: &str,
        operation: TransformOperation,
        timestamp: u64,
    ) {
        // Create output node if it doesn't exist
        let output_node_id = if let Some(id) = self.key_to_node.get(output_key) {
            id.clone()
        } else {
            self.create_node(
                output_key,
                DataSource::Computed {
                    operation: format!("{:?}", operation),
                },
                HashMap::new(),
                timestamp,
            )
        };

        // Update node type
        if let Some(node) = self.nodes.get_mut(&output_node_id) {
            node.node_type = LineageNodeType::Derived;
            node.modified_at = timestamp;
        }

        // Add edges from each input
        for input_key in input_keys {
            if let Some(input_node_id) = self.key_to_node.get(input_key) {
                let edge = LineageEdge {
                    source: input_node_id.clone(),
                    target: output_node_id.clone(),
                    edge_type: LineageEdgeType::TransformInput,
                    timestamp,
                    operation: Some(format!("{:?}", operation)),
                };

                self.outgoing_edges
                    .entry(input_node_id.clone())
                    .or_default()
                    .push(edge.clone());
                self.incoming_edges
                    .entry(output_node_id.clone())
                    .or_default()
                    .push(edge);
            }
        }
    }

    fn add_derivation(&mut self, source_key: &str, derived_key: &str, timestamp: u64) {
        // Get or create source node
        let source_node_id = if let Some(id) = self.key_to_node.get(source_key) {
            id.clone()
        } else {
            self.create_node(source_key, DataSource::Unknown, HashMap::new(), timestamp)
        };

        // Create derived node
        let derived_node_id = self.create_node(
            derived_key,
            DataSource::Computed {
                operation: "derivation".to_string(),
            },
            HashMap::new(),
            timestamp,
        );

        // Update derived node type
        if let Some(node) = self.nodes.get_mut(&derived_node_id) {
            node.node_type = LineageNodeType::Derived;
        }

        // Add edge
        let edge = LineageEdge {
            source: source_node_id.clone(),
            target: derived_node_id.clone(),
            edge_type: LineageEdgeType::DerivedFrom,
            timestamp,
            operation: Some("derive".to_string()),
        };

        self.outgoing_edges
            .entry(source_node_id)
            .or_default()
            .push(edge.clone());
        self.incoming_edges
            .entry(derived_node_id)
            .or_default()
            .push(edge);
    }

    fn add_merge(&mut self, source_keys: &[String], target_key: &str, timestamp: u64) {
        // Create target node
        let target_node_id = self.create_node(
            target_key,
            DataSource::Computed {
                operation: "merge".to_string(),
            },
            HashMap::new(),
            timestamp,
        );

        // Update target node type
        if let Some(node) = self.nodes.get_mut(&target_node_id) {
            node.node_type = LineageNodeType::Aggregated;
        }

        // Add edges from each source
        for source_key in source_keys {
            if let Some(source_node_id) = self.key_to_node.get(source_key) {
                let edge = LineageEdge {
                    source: source_node_id.clone(),
                    target: target_node_id.clone(),
                    edge_type: LineageEdgeType::MergedFrom,
                    timestamp,
                    operation: Some("merge".to_string()),
                };

                self.outgoing_edges
                    .entry(source_node_id.clone())
                    .or_default()
                    .push(edge.clone());
                self.incoming_edges
                    .entry(target_node_id.clone())
                    .or_default()
                    .push(edge);
            }
        }
    }

    fn mark_deleted(&mut self, key: &str, timestamp: u64) {
        if let Some(node_id) = self.key_to_node.get(key) {
            if let Some(node) = self.nodes.get_mut(node_id) {
                node.node_type = LineageNodeType::Deleted;
                node.modified_at = timestamp;
            }
        }
    }

    /// Get lineage for a key
    pub fn get_lineage(&self, key: &str) -> DataLineage {
        let node_id = self.key_to_node.get(key);
        let node = node_id.and_then(|id| self.nodes.get(id).cloned());

        let (upstream, downstream, edges, depth) = if let Some(id) = node_id {
            let upstream = self.get_upstream(id);
            let downstream = self.get_downstream(id);
            let edges = self.collect_edges(id);
            let depth = self.calculate_depth(id);
            (upstream, downstream, edges, depth)
        } else {
            (vec![], vec![], vec![], 0)
        };

        DataLineage {
            key: key.to_string(),
            node,
            upstream,
            downstream,
            edges,
            depth,
        }
    }

    /// Get upstream nodes (ancestors)
    fn get_upstream(&self, node_id: &NodeId) -> Vec<LineageNode> {
        let mut visited = HashSet::new();
        let mut result = Vec::new();
        let mut queue = VecDeque::new();

        // Start with incoming edges
        if let Some(edges) = self.incoming_edges.get(node_id) {
            for edge in edges {
                queue.push_back(edge.source.clone());
            }
        }

        while let Some(current_id) = queue.pop_front() {
            if visited.contains(&current_id) {
                continue;
            }
            visited.insert(current_id.clone());

            if let Some(node) = self.nodes.get(&current_id) {
                result.push(node.clone());
            }

            // Add incoming edges of current node
            if let Some(edges) = self.incoming_edges.get(&current_id) {
                for edge in edges {
                    if !visited.contains(&edge.source) {
                        queue.push_back(edge.source.clone());
                    }
                }
            }
        }

        result
    }

    /// Get downstream nodes (descendants)
    fn get_downstream(&self, node_id: &NodeId) -> Vec<LineageNode> {
        let mut visited = HashSet::new();
        let mut result = Vec::new();
        let mut queue = VecDeque::new();

        // Start with outgoing edges
        if let Some(edges) = self.outgoing_edges.get(node_id) {
            for edge in edges {
                queue.push_back(edge.target.clone());
            }
        }

        while let Some(current_id) = queue.pop_front() {
            if visited.contains(&current_id) {
                continue;
            }
            visited.insert(current_id.clone());

            if let Some(node) = self.nodes.get(&current_id) {
                result.push(node.clone());
            }

            // Add outgoing edges of current node
            if let Some(edges) = self.outgoing_edges.get(&current_id) {
                for edge in edges {
                    if !visited.contains(&edge.target) {
                        queue.push_back(edge.target.clone());
                    }
                }
            }
        }

        result
    }

    /// Collect all edges related to a node
    fn collect_edges(&self, node_id: &NodeId) -> Vec<LineageEdge> {
        let mut edges = Vec::new();

        if let Some(outgoing) = self.outgoing_edges.get(node_id) {
            edges.extend(outgoing.iter().cloned());
        }

        if let Some(incoming) = self.incoming_edges.get(node_id) {
            edges.extend(incoming.iter().cloned());
        }

        edges
    }

    /// Calculate depth (max hops to a root node)
    fn calculate_depth(&self, node_id: &NodeId) -> usize {
        let mut visited = HashSet::new();
        self.depth_recursive(node_id, &mut visited)
    }

    fn depth_recursive(&self, node_id: &NodeId, visited: &mut HashSet<NodeId>) -> usize {
        if visited.contains(node_id) {
            return 0;
        }
        visited.insert(node_id.clone());

        let incoming = match self.incoming_edges.get(node_id) {
            Some(edges) if !edges.is_empty() => edges,
            _ => return 0,
        };

        let max_parent_depth = incoming
            .iter()
            .map(|edge| self.depth_recursive(&edge.source, visited))
            .max()
            .unwrap_or(0);

        max_parent_depth + 1
    }

    /// Get recent events
    pub fn get_events(&self, limit: usize) -> Vec<LineageEvent> {
        self.events.iter().rev().take(limit).cloned().collect()
    }

    /// Get all nodes
    pub fn get_all_nodes(&self) -> Vec<LineageNode> {
        self.nodes.values().cloned().collect()
    }

    /// Get all edges
    pub fn get_all_edges(&self) -> Vec<LineageEdge> {
        self.outgoing_edges
            .values()
            .flat_map(|edges| edges.iter().cloned())
            .collect()
    }

    /// Clear lineage data
    pub fn clear(&mut self) {
        self.nodes.clear();
        self.key_to_node.clear();
        self.outgoing_edges.clear();
        self.incoming_edges.clear();
        self.events.clear();
    }
}

impl Default for LineageGraph {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_create_event() {
        let mut graph = LineageGraph::new();

        graph.add_event(LineageEvent::Create {
            key: "user:1".to_string(),
            source: DataSource::Api {
                user_id: Some("admin".to_string()),
                client_ip: None,
            },
            timestamp: 1000,
            metadata: HashMap::new(),
        });

        let lineage = graph.get_lineage("user:1");
        assert!(lineage.node.is_some());
        assert_eq!(lineage.node.unwrap().key, "user:1");
    }

    #[test]
    fn test_derive_event() {
        let mut graph = LineageGraph::new();

        // Create source
        graph.add_event(LineageEvent::Create {
            key: "source".to_string(),
            source: DataSource::Api {
                user_id: None,
                client_ip: None,
            },
            timestamp: 1000,
            metadata: HashMap::new(),
        });

        // Derive
        graph.add_event(LineageEvent::Derive {
            source_key: "source".to_string(),
            derived_key: "derived".to_string(),
            timestamp: 2000,
        });

        let lineage = graph.get_lineage("derived");
        assert_eq!(lineage.upstream.len(), 1);
        assert_eq!(lineage.upstream[0].key, "source");
    }

    #[test]
    fn test_transform_event() {
        let mut graph = LineageGraph::new();

        // Create inputs
        graph.add_event(LineageEvent::Create {
            key: "input1".to_string(),
            source: DataSource::Unknown,
            timestamp: 1000,
            metadata: HashMap::new(),
        });

        graph.add_event(LineageEvent::Create {
            key: "input2".to_string(),
            source: DataSource::Unknown,
            timestamp: 1000,
            metadata: HashMap::new(),
        });

        // Transform
        graph.add_event(LineageEvent::Transform {
            input_keys: vec!["input1".to_string(), "input2".to_string()],
            output_key: "output".to_string(),
            operation: TransformOperation::Aggregate {
                function: "SUM".to_string(),
            },
            timestamp: 2000,
        });

        let lineage = graph.get_lineage("output");
        assert_eq!(lineage.upstream.len(), 2);
        assert_eq!(lineage.depth, 1);
    }

    #[test]
    fn test_merge_event() {
        let mut graph = LineageGraph::new();

        // Create sources
        for i in 1..=3 {
            graph.add_event(LineageEvent::Create {
                key: format!("part{}", i),
                source: DataSource::Unknown,
                timestamp: 1000,
                metadata: HashMap::new(),
            });
        }

        // Merge
        graph.add_event(LineageEvent::Merge {
            source_keys: vec![
                "part1".to_string(),
                "part2".to_string(),
                "part3".to_string(),
            ],
            target_key: "merged".to_string(),
            timestamp: 2000,
        });

        let lineage = graph.get_lineage("merged");
        assert_eq!(lineage.upstream.len(), 3);
        assert_eq!(lineage.node.unwrap().node_type, LineageNodeType::Aggregated);
    }

    #[test]
    fn test_downstream_tracking() {
        let mut graph = LineageGraph::new();

        // Create source
        graph.add_event(LineageEvent::Create {
            key: "root".to_string(),
            source: DataSource::Unknown,
            timestamp: 1000,
            metadata: HashMap::new(),
        });

        // Derive multiple
        graph.add_event(LineageEvent::Derive {
            source_key: "root".to_string(),
            derived_key: "child1".to_string(),
            timestamp: 2000,
        });

        graph.add_event(LineageEvent::Derive {
            source_key: "root".to_string(),
            derived_key: "child2".to_string(),
            timestamp: 3000,
        });

        let lineage = graph.get_lineage("root");
        assert_eq!(lineage.downstream.len(), 2);
    }

    #[test]
    fn test_delete_event() {
        let mut graph = LineageGraph::new();

        graph.add_event(LineageEvent::Create {
            key: "temp".to_string(),
            source: DataSource::Unknown,
            timestamp: 1000,
            metadata: HashMap::new(),
        });

        graph.add_event(LineageEvent::Delete {
            key: "temp".to_string(),
            timestamp: 2000,
        });

        let lineage = graph.get_lineage("temp");
        assert_eq!(lineage.node.unwrap().node_type, LineageNodeType::Deleted);
    }
}
